" Neobundle  " {{{1
if has('vim_starting')
    set runtimepath+=~/.vim/bundle/neobundle.vim/
endif
call neobundle#rc(expand('~/.vim/bundle/'))
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc.vim', {
            \   'build' : {
            \       'mac' : 'make -f make_mac.mak',
            \       'unix' : 'make -f make_unix.mak',
            \   },
            \ }
NeoBundle 'kana/vim-fakeclip'
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'kana/vim-textobj-entire'
NeoBundle 'kana/vim-textobj-line'
NeoBundle 'kana/vim-textobj-function'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle 'kana/vim-operator-user'
NeoBundle 'rhysd/vim-clang-format'
NeoBundle 'thinca/vim-quickrun'
NeoBundleLazy 'vim-jp/cpp-vim', { 'autoload' : { 'filetypes' : ['cpp'] } }
NeoBundle 'chriskempson/base16-vim'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'vim-jp/vimdoc-ja'

filetype plugin indent on
NeoBundleCheck
" 1}}}

" Basic Settings  " {{{1
" Base  " {{{2
augroup MyAutoCmd
    autocmd!
augroup END

language message C
language time C

" help language
set helplang=en,ja

let g:is_darwin_p = has('mac') || has('macunix')
let g:is_linux_p = !g:is_darwin_p && has('unix')
" 2}}}
" Edit  " {{{2
" encoding
set termencoding=utf-8
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,cp932

" tab settings
set softtabstop=4 shiftwidth=4 tabstop=4
set autoindent
set smarttab
set shiftround
set noexpandtab

" comment
autocmd MyAutoCmd Filetype * setlocal formatoptions-=ro

" move bol<->eol
set whichwrap=b,s,h,l,[,],<,>,~

" autoreload
set autoread

" enable backspace delete indent eol newline
set backspace=indent,eol,start
" 2}}}
" Search & Replace  " {{{2
set incsearch
set ignorecase
set smartcase
set wrapscan
set hlsearch
nohlsearch
" 2}}}
" Appearance  " {{{2
" disable startup message
set shortmess=aoOIt
" show match paren
set showmatch
" open new window into bottom
set splitbelow splitright

set nrformats-=octal

" cursorline
set cursorline

" show line number
set number
set ruler

set wrap

set ambiwidth=double

" always show statuslines
set laststatus=2
set cmdheight=2
set showcmd
" always show tabline
set showtabline=2

" command line
set wildmenu
set wildchar=<TAB>
set wildmode=longest:full,full

set list
set listchars=tab:»\ ,trail:_

" set tabline  " {{{3
function! s:SID_PREFIX()
    return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction
function! s:my_tabline()
    let s = ''
    for i in range(1, tabpagenr('$'))
        let bufnrs = tabpagebuflist(i)
        let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
        let no = i  " display 0-origin tabpagenr.
        let mod = getbufvar(bufnr, '&modified') ? '!' : ' '
        let title = fnamemodify(bufname(bufnr), ':t')
        if title == ''
            let title = 'No Name'
        endif
        let title = '[' . title . ']'
        let s .= '%'.i.'T'
        let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
        let s .= no . ':' . title
        let s .= mod
        let s .= '%#TabLineFill# '
    endfor
    let s .= '%#TabLineFill#%T%=%#TabLine#'
    return s
endfunction
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
" 3}}}

" ColorScheme
if !has('gui_running')
    set t_Co=256
    let g:base16colorspace=256
endif
set background=dark
syntax enable
colorscheme base16-ocean
" 2}}}
" Other  " {{{2
" disable bell
set visualbell
set t_vb=
set noerrorbells

" clipboard
set clipboard=unnamed

" completion
set completeopt=menu,menuone

set history=100

" enable mouse
set mouse=a

set scrolloff=3
set sidescrolloff=5
set sidescroll=1

set ttyfast

" enable folding
set foldenable
set foldmethod=marker

" backup directory
set directory=$HOME/.vim/backups
set backupdir=$HOME/.vim/backups
"set noswap
"set nobackup

" undo
set undofile
set undodir=~/.vim/undo

" goto last changed place
autocmd MyAutoCmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g`\"" | endif

" とりあえず作ってみたので試験運用
function! CD_test()
    let l:dest1 = fnameescape(expand('%:p:h'))
    execute 'lcd ' . dest1
    if (system('git rev-parse --is-inside-work-tree') ==# 'true\n')
        let l:dest2 = fnameescape(system('git rev-parse --show-toplevel'))
        execute 'lcd ' . dest2
    endif
    pwd
endfunction
nnoremap <silent> <Space>cd  :<C-u>call CD_test()<CR>
" 2}}}
" 1}}}

" Mapping  " {{{1
" show list of all mappnig
" :Allmaps
" :verbose Allmaps <buffer>
command!
            \   -nargs=* -complete=mapping
            \   AllMaps
            \   map <args> | map! <args> | lmap <args>
" Normal-mode keymapping  " {{{2

" drillpractice
nnoremap <Left> <Nop>
nnoremap <Right> <Nop>
nnoremap <Up> <Nop>
nnoremap <Down> <Nop>

" quick help
nnoremap <C-h>  :<C-u>help<Space>
nnoremap ,h :<C-u>help<Space><C-r><C-w><CR>
" to avoid gobaku
nnoremap <F1> <Nop>

" toggle wrap
nnoremap <Space>ow
            \  :<C-u>setlocal wrap!
            \ \|     setlocal wrap?<CR>

" disable dangerous command
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>

" macro
nnoremap Q q

" disable EX-mode
nnoremap q <Nop>

" linux only
if g:is_linux_p
    nnoremap ; :
    nnoremap : ;
endif

" edit vimrc and reload
nnoremap <Space>.   :<C-u>edit $HOME/repo/vimrc/dot.vimrc_practice<CR>
nnoremap <Space>t.  :<C-u>tabnew $HOME/repo/vimrc/dot.vimrc<CR>
nnoremap <Space>s.  :<C-u>source $HOME/repo/vimrc/dot.vimrc_practice<CR>
" 2}}}
" Insert-mode keymapping " {{{2
inoremap <C-f> <Right>
inoremap <C-b> <Left>
inoremap <C-a> <Home>
inoremap <C-e> <End>
inoremap <C-d> <Del>
" 2}}}
" Command-mode keymapping  " {{{2
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <C-a> <Home>
cnoremap <C-e> <End>
cnoremap <M-b> <S-Left>
cnoremap <M-f> <S-Right>

" escape /
cnoremap <expr> / getcmdtype() == '/' ? '\/' : '/'
" 2}}}
" 1}}}

" vim-fugitive  " {{{1
nnoremap <Leader>gs :<C-u>Gstatus<CR>
nnoremap <Leader>gc :<C-u>Gcommit -v<CR>
nnoremap <Leader>gC :<C-u>Gcommit<CR>
nnoremap <Leader>ga :<C-u>Gwrite<CR>
nnoremap <Leader>gd :<C-u>Gdiff<CR>
nnoremap <Leader>gb :<C-u>Gblame<CR>
nnoremap <Leader>gp :<C-u>Git push<CR>
nnoremap <Leader>gP :<C-u>Git pull<CR>
" 1}}}"
" quickrun  " {{{1
" default settings
let g:quickrun_config = {}
let g:quickrun_config._ = {
            \   'outputter' : 'error',
            \   'outputter/error/success' : 'buffer',
            \   'outputter/error/error' : 'quickfix',
            \   'outputter/buffer/split' : ':botright 8sp',
            \   'outputter/buffer/close_on_empty' : 1,
            \   'runner' : 'vimproc',
            \   'runner/vimproc/updatetime' : 60,
            \ }
let g:quickrun_config.c = {
            \   'type' : 'c/clang',
            \   'cmdopt' : '-fno-caret-diagnostics',
            \ }
let g:quickrun_config.cpp = {
            \   'type' : 'cpp/clang++',
            \   'cmdopt' : '-std=c++11 -fno-caret-diagnostics',
            \ }
" for compile
let g:quickrun_config.cpp_compile = {
            \   'command' : 'clang++',
            \   'cmdopt' : '-std=c++11 -Wall -Wextra',
            \   'exec' : '%c %o -o %s:r %s:p',
            \   'outputter' : 'quickfix',
            \ }
let g:quickrun_config.c_compile = {
            \   'command' : 'clang',
            \   'cmdopt' : '-std=c11 -Wall -Wextra',
            \   'exec' : '%c %o -o %s:r %s:p',
            \   'outputter' : 'quickfix',
            \ }
let g:quickrun_config.haskell_compile = {
            \   'command' : 'ghc',
            \   'cmdopt' : '-O --make',
            \   'exec' : '%c %o -o %s:r %s:p',
            \   'outputter' : 'quickfix',
            \ }

autocmd MyAutoCmd FileType c nnoremap <buffer> <Leader>R :<C-u>QuickRun c_compile<CR>
autocmd MyAutoCmd FileType cpp nnoremap <buffer> <Leader>R :<C-u>QuickRun cpp_compile<CR>
autocmd MyAutoCmd FileType haskell nnoremap <buffer> <Leader>R :<C-u>QuickRun haskell_compile<CR>
" 1}}}
" operator  " {{{1
" clang-format  " {{{2
autocmd MyAutoCmd FileType cpp map <buffer> <Leader>x <Plug>(operator-clang-format)
" Mac: homebrew
" Linux: build from source and make symbolic link
let g:clang_format#command = 'clang-format-3.5'
let g:clang_format#code_style = 'LLVM'
let g:clang_format#style_options = {
            \   'AccessModifierOffset' : -4,
            \   'AllowShortIfStatementsOnASingleLine' : 'true',
            \   'AllowShortFunctionsOnASingleLine' : 'true',
            \   'AlwaysBreakTemplateDeclarations' : 'true',
            \   'Standard' : 'Cpp11',
            \   'PointerBindsToType' : 'true',
            \   'BreakBeforeBraces' : 'Stroustrup',
            \   'IndentWidth' : 4,
            \   'TabWidth' : 4,
            \   'UseTab' : 'ForIndentation',
            \ }
" 2}}}
" orerator-sort  " {{{2

" 2}}}
" 1}}}

function! DeleteTrailingSpaces()
    %s/\s\+$//e
endfunction

" to avoid to load smartinput setting
let g:smartinput_haskell_loaded = 1
let g:smartinput_c_loaded = 1
let g:smartinput_cpp_loaded = 1

" vim: set ft=vim fdm=marker :

